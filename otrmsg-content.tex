\title[Deniability of OTR]{%
  On the Deniability of Off-The-Record Messaging
}
\author[D.~Bosk]{%
  Daniel Bosk
}
\institute[KTH]{%
  School of Computer Science and Communication,\\
  KTH Royal Institute of Technology\\
  \email{dbosk@kth.se}
}
\date[kaucrypt 2015]{%
  KaU Crypto Course,
  24th August 2015
}

\mode<presentation>{%
  \begin{frame}<presentation>
    \titlepage{}
  \end{frame}
  \begin{frame}<presentation>{Overview}
    \tableofcontents
  \end{frame}
}
\mode<article>{\maketitle}

\mode* % required for slides to compile without non-frame text

\begin{abstract}
  In this talk we explore the \ac{OTR} messaging protocol and some of its 
  derivatives.
  We cover its main properties and how they are achieved.
  Then we discuss whether these hold under a surveillance-state adversary and 
  finally give some suggestions which could improve the situation.

  \keywords{%
    Off-the-Record Messaging,
    Deniability
  }
\end{abstract}


% Since this a solution template for a generic talk, very little can
% be said about how it should be structured. However, the talk length
% of between 15min and 45min and the theme suggest that you stick to
% the following rules:
% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.


\acresetall{}
\section{Introduction}

% XXX rewrite intro, fetch from surveillance reflections
In 2013, Edward Snowden~\cite{landau2013making} revealed the capabilities of 
the \ac{NSA}, \ac{GCHQ} and their collaborators~\cite[e.g.][]{nsa1,nsa2}.
That showed the techniques considered possible to use against high-value 
targets now, were routinely used against not only all targets, but against all 
citizens of the world.
In light of this, we should reconsider Eve's capabilities.

In 2004, \citeauthor{otr2004}~\cite{otr2004} first described the \ac{OTR} 
messaging protocol.
The design goal of the protocol is to achieve strong privacy properties for 
users' online communication, the same properties as expected from 
a face-to-face conversation.
The main application at the time was \ac{IM} through tools like Pidgin 
\cite{pidgin} (formerly Gaim).
\ac{IM} is still used, however, the context has changed.
Since 2004, users communicate more and more via Facebook, Twitter, and other 
\acp{OSN}, and they use smartphones instead of computers.
Later improvements occurred in 2007~\cite{otr2007} and 2009~\cite{multiotr2009}.
In 2010, OpenWhisperSystems updated and implemented the \ac{OTR} messaging 
protocol for use in the smartphone text-messaging app TextSecure 
\cite{textsecure}.
So today many technologies relies on it.

The protocol is designed to provide the following properties:
\begin{itemize}
  \item confidentiality and \ac{PFS},
  \item authenticated communication with repudiation for the authentication 
    mechanism,
  \item plausible deniability and forgeability for the messages.
\end{itemize}
The \ac{NSA} and \ac{GCHQ} can (apparently) not break the confidentiality of 
\ac{OTR} yet~\cite{spiegelotr}.
But if we consider what we know of their capabilities, some of these properties 
are \emph{possibly} no longer provided.
Repudiation and plausible deniability cannot be achieved by this protocol 
design considering an adversary who can record everything on the entire 
network.
Lack of randomness in the \ac{DHKE}\acused{DH}~\cite{dh} used by \ac{OTR} makes 
the protocol fully deterministic (details in \prettyref{sec:otr}).
In \prettyref{sec:otrattacks} we show that this allows an adversary with 
transcripts of all network traffic to verify any statements about the 
conversation using the transcripts.
To thwart this we need truly deniable encryption, as defined by 
\citet{deniablecrypt}, which means that we need to introduce some randomness.


\section{The \acs{OTR} Messaging Protocol}
\label{sec:otr}

In this section, we summarize the original version of the \ac{OTR} messaging 
protocol published in~\cite{otr2004} together with the improvements from 
\cite{di2005secure}.

As described above, the purpose of the \ac{OTR} protocol was to give an online 
conversation the properties of a face-to-face real-life conversation.
We start with an overview of the properties and how they are achieved:
\begin{description}
  \item[Perfect forward secrecy] is achieved by continuously changing keys, for 
    every message, using the \ac{DHKE} protocol~\cite{dh}.
    It is of crucial importance for Alice and Bob to forget their keys as soon 
    as possible to achieve this.

  \item[Authentication] is be achieved by using non-refutable signatures so 
    that Bob can verify with whom he is exchanging messages.
    These keys are long-lived to make it easier for Alice and Bob to trust the 
    signatures.
    However, no message content will be signed, only the first \ac{DH} exponent 
    will be signed.

  \item[Integrity and repudiation] for message content will be achieved by 
    using \acp{MAC}.
    Since \acp{MAC} does not provide non-repudiation, Alice can later 
    repudiate sending a certain message as Bob has the means to forge it.

  \item[Forgeability and plausible deniability] of message content is achieved 
    by using malleable encryption~\cite{nonmalleable}.
    This means that an adversary can do meaningful changes in the plaintext by 
    changing the ciphertext without knowing the key.
    \ac{OTR} uses a stream cipher for this.
\end{description}

The protocol is strictly two-party, so Alice and Bob can talk privately, but no 
more people can participate.
The description of the protocol is divided into two parts: initialization and 
communication.

\subsection{\acs{OTR} Initialization}

To communicate using \ac{OTR}, Alice and Bob first runs the protocol in 
\prettyref{prot:otrinit}.

\begin{protocol}[\acs{OTR} initialization]\label{prot:otrinit}
  Alice and Bob agree on a multiplicative group \(G\) of prime order \(p\) and 
  a generator \(g\in G\).
  Alice has a signature and verification key-pair \((S_A, V_A)\) and Bob has 
  correspondingly \((S_B, V_B)\).

  Alice chooses a random key \(r\in \K\), from the key-space of the encryption 
  algorithm \(\Enc\), and \(x_1\in \Z_{\ord G}\).
  Bob chooses a random \(y_1\in \Z_{\ord G}\).
  Then they exchange the following:
  \begin{align*}
    A\to B &\colon \Enc_r( g^{x_1} ), H( g^{x_1} ) \\
    B\to A &\colon g^{y_1} \\
    A\to B &\colon r
  \end{align*}

  Next, Alice and Bob derives \ac{MAC} keys \(f_{a,1}( g^{xy} ), f_{a,2}( 
  g^{xy} ), f_{b,1}( g^{xy} ), f_{b,2}( g^{xy} )\) and encryption keys \(h_a( 
  g^{xy} ), h_b( g^{xy} )\) using some suitable one-way functions \(f_{a,1}, 
  f_{a,2}, f_{b,1}, f_{b,2}, h_a, h_b\).
  Alice computes \[M_A = \MAC_{f_{a,1}(g^{xy})}( g^{x_1}, g^{y_1}, V_A 
  )\textand X_A = ( V_A, \Sign_{S_A}( M_A ) ).\]
  She then sends
  \begin{align*}
    A\to B\colon c = \Enc_{h_a(g^{xy})}( X_A ), \MAC_{f_{a,2}(g^{xy})}( c )
  \end{align*}
  to Bob.
  Bob verifies the received values and computes \[M_B = \MAC_{f_{b,1}(g^{xy})}( 
    g^{y_1}, g^{x_1}, V_B )\textand X_B = ( V_B, \Sign_{S_B}( M_B ) ).\]
  He then sends
  \begin{align*}
    B\to A\colon c^\prime = \Enc_{h_b(g^{xy})}( X_B ), \MAC_{f_{b,2}(g^{xy})}( 
    c^\prime )
  \end{align*}
  to Alice, who verifies the received values which concludes the 
  initialization.
\end{protocol}

Alice and Bob now has both \(g^{x_1}\in G\) and \(g^{y_1}\in G\) and can hence 
compute \(g^{x_1 y_1}\in G\) which can be used to derive keys.
Further, since the key exchange protocol is authenticated they can believe they 
are talking to the right person.

\subsection{\acs{OTR} Communication}

After initializing the session, Alice and Bob can start their conversation 
exchanging messages \(m_1, m_2, \ldots, m_n\).
This is accomplished in the following way:

\begin{protocol}[\acs{OTR} communication]\label{prot:otrcomm}
  Assume Alice has sent \(g^{x_i}\) to Bob and she has received \(g^{y_j}\) 
  from Bob.
  Further, let \(H_E, H_M\) be collision-resistant hash functions.

  When Alice wants to send a message \(m_k\) to Bob, she chooses a random 
  \(x_{i+1}\in\Z_{\ord G}\) and sends
  \begin{equation*}
    A\to B\colon g^{x_{i+1}},
    c_k = \Enc_{H_E( g^{x_i y_j} )}( k )\oplus m_k,
    \MAC_{H_M( g^{x_i y_j} )}( g^{x_{i+1}}, c_k )
  \end{equation*}
  to Bob.

  Later, when Bob wants to reply a message \(m_{k+1}\), he chooses a random 
  \(y_{j+1}\in\Z_{\ord G}\) and the latest \(g^{x_{i+n}}\) received from Alice, 
  and then sends
  \begin{align*}
    B\to A\colon& g^{y_{j+1}}, c_{k+1} = \Enc_{H_E( g^{x_{i+n} y_j} )}( k+1 
    )\oplus m_{k+1}, \\
    & \MAC_{H_M( g^{x_{i+n} y_j} )}( g^{y_{j+1}}, c_{k+1} )
  \end{align*}
  to Alice.

  Once Alice knows that a message sent to Bob has been received, she publishes 
  the \ac{MAC} key \( H_M( g^{x_i y_j} ) \) for that message as part of her 
  next message.
\end{protocol}

We can see in Protocol~\ref{prot:otrcomm} that we get a continuous \ac{DHKE} 
by using the transmission of each message for exchanging the value to be used 
for the next message.
Hence we never use the same key twice.
We remain authenticated as well, since we provide authenticity for the next 
\ac{DH} value using a \ac{MAC} keyed with a previously authenticated key.
However, since the authentication is done using \acp{MAC}, Bob can never 
prove to anyone else what Alice has written.
And after Alice publishes the \ac{MAC} key, anyone can create messages which 
authenticates using that \ac{MAC} key.
Thus, no one can use the \ac{MAC} to verify the message in the future.

For the \ac{PFS}, we need Alice and Bob to forget the keys \(g^{x_i y_j}\) as 
soon as possible.
We observe that Alice must keep her secret values \(x_i, x_{i+1}, \ldots, 
x_{i+n}\) until she has received a message from Bob using a newer value.
If she does not, then she cannot decrypt any message from Bob using that value 
in the key.


\section{Why Alice and Bob Must Forget Their Conversation}
\label{sec:otrattacks}

The protocol does not consider the intelligence agency of a nation state as 
a possible adversary.
Below we outline what an adversary with the known capabilities of \ac{NSA} and 
\ac{GCHQ} can do.

In this new adversarial setting Eve controls the network and can with high 
probability compromise a computer system at will.
More importantly, the nation state does not have to present non-reputable 
evidence to a third-party judge, it just has to convince itself: 
\blockcquote{metadatakill}{We kill based on meta-data}.
We argue that in this setting the algorithms employed in the \ac{OTR} protocol 
are \enquote{too secure} for our own good.
We will elaborate on this.

\subsection{Verifying Who Sent What}

The arguments of \citet{otr2004} for forgeability using malleable encryption 
and publishing the \ac{MAC} keys only hold if the adversary cannot trust the 
source of the transcript.
The more powerful Eve can ultimately trust the transcript since she collected 
it herself from the network.
She then knows exactly which ciphertext Alice sent to Bob, and which ciphertext 
Bob replied.

In this setting the forgeability property vanishes.
Eve knows that no one has modified the ciphertext, she recorded in her 
transcript as it left Alice and arrived to Bob.
She also recorded Alice publishing the \ac{MAC} key used for the signature.
This allows Eve to use the \ac{MAC} for each ciphertext to verify them.
She knows that Alice is the author of a message because she observes when Alice 
publishes the \ac{MAC} key.

The fact that Eve maintains this transcript is clear from~\cite{spiegelotr}, 
which is exactly such a transcript.

\subsection{Verifying Plaintext on Compromise of a System}

In addition to knowing who sent what ciphertext, Eve knows the lengths of these 
ciphertexts and she knows the time they were sent and the order in which they 
arrived.
When Eve compromises Bob's system, she might be able to see some history of the 
conversation in his client.
She can then infer who wrote what thanks to the meta-data in her records, 
e.g.~message length and ordering.
(Eve can also use author-identification techniques to detect Alice's writing 
style in the plaintexts found at Bob's.)

\subsection{Verifying Encryption Keys}

Furthermore, Eve also learns some information about the key from the ciphertext 
and \ac{MAC}.
Eve can use the \ac{MAC} to discard false keys for the ciphertext.
A simple algorithm is presented as \alg{IsTrueKey} in 
\prettyref{alg:falsekeys}.
Hence, by having the \ac{MAC} key depend on the encryption key, we 
automatically decrease the number of spurious keys and thus also reduce our 
possibility for deniability.

\begin{algorithm}
  \caption{%
    Algorithm for finding possible plaintexts and discarding false keys.
  }\label{alg:falsekeys}
  \begin{algorithmic}
    \Function{IsTrueKey}{$C, M, k$}\Comment{%
      Ciphertext $C$, \ac{MAC} $M$, key $k$.
    }
      \If{$\MAC_{H(k)}( C ) = M$}
        \State{\Return{True}}
      \EndIf{}
      \State{\Return{False}}
    \EndFunction{}

    \Statex{}
    \Function{Decrypt}{$C, M$}\Comment{Ciphertext $C$ and \ac{MAC} $M$.}
      \State{Let $P = \emptyset$.}
      \ForAll{$k\in \K$}\Comment{Keyspace $\K$}
        \If{\Call{IsTrueKey}{$C, M, k$}}
          \State{Let $P = P\cup \Dec_k( C )$.}
        \EndIf{}
      \EndFor{}
      \State{\Return{$P$}}
    \EndFunction{}
  \end{algorithmic}
\end{algorithm}

The time complexity for the function \alg{Decrypt} in \prettyref{alg:falsekeys} 
depends on the size of the key-space, \(O(\card\K)\), and is still much too 
large.

\subsection{How Impossible Is Deniability?}

As suggested above, we have hard times achieving deniability.
This is illustrated by the following equations:
Assume
\begin{equation*}
  \Enc_{H_E(k)}( m ) = c = \Enc_{H_E(k^\prime)}( m^\prime )
\end{equation*}
and \(k\neq k^\prime\), then
\begin{equation*}
  \Pr\left[
    \MAC_{H_M(k)}( c ) = \MAC_{H_M(k^\prime)}( c )
  \right]
  \approx
  \Pr\left[ H_M(k) = H_M(k^\prime) \right].
\end{equation*}
I.e.~our chance of lying about the key \(k\), replacing it with a key 
\(k^\prime\), is reduced to finding a collision for the hash function \(H_M\).
(There is also the negligible probability of \(\MAC_x(c) = \MAC_{x^\prime}(c)\) 
for \(x\neq x^\prime\).)

Furthermore, we find the key \(k^\prime\) by finding the preimage of \(H_E( 
k^\prime )\).
And if the encryption system \(\Enc\) is known-plaintext resistant, then we 
will first have a hard time even finding \(H_E( k^\prime )\) before we can 
attempt finding its preimage.

With above reasoning, we have showed that \ac{OTR} cannot be deniable according 
to the definition of~\cite{deniablecrypt}: there cannot exist any 
polynomial-time algorithm \(\phi\) which returns the key \(k^\prime\), hence it 
cannot be deniable.


\section{Achieving Deniability}

To be able to get deniability in the given scenario, Alice and Bob need to be 
able to modify the plaintext without modifying the ciphertext.
They also need a \ac{MAC} key independent from the encryption key.
Then they can change the encryption key and the plaintext, but the ciphertext 
and \ac{MAC} remains the same.

\subsection{Making It Easy to Find \(k^\prime\)}

The first encryption system that comes to mind when thinking of known-plaintext 
attacks is \ac{OTP}.
If \(\Enc\) used above would be replaced with \ac{OTP}, then you can easily 
compute the false key \(k^\prime\) from a given plaintext-ciphertext pair.

There is also the possibility of constructing a system composed of several hard 
problems, e.g.~factorization and discrete logarithms.
Then adjusting one of the secrets while keeping the other fixed \emph{might} 
allow you to compute a new key without the system being vulnerable to 
known-plaintext attacks.

\subsection{Increasing the Number of Spurious Keys}

We also want to resolve the problem of tying our hands with the \ac{MAC}.
Instead of using deriving the keys from \(g^{xy}\in G\) as \(H_E(g^{xy})\) for 
encryption and \(H_M(g^{xy})\) for \ac{MAC}, Alice and Bob can increase the 
size \(\ord G\) of the group \(G\) and use the \(n\) least significant bits of 
\(g^{xy}\) for \ac{MAC} and the rest for encryption.
Choosing a group which gives a key-size of 2048 bits, using 256 bits for 
\ac{MAC} leaves 1792 bits for encryption with \ac{OTP}.
That is 224 bytes, which is larger than what Twitter allows for a tweet (140 
characters).
This way, when using the \ac{OTP} they can keep the \ac{MAC} key fixed while 
adapting the encryption key to their new plaintext, then hand the complete key 
(both \ac{MAC} and encryption) to the adversary.

\subsection{The Remaining Verification Problem}

The adversary Eve has now two options for verifying whether a given key \(k\) 
is true or false.
First, she can find the discrete logarithm \(s = \log_g( k )\) of \(k 
= g^{xy}\) in the base \(g\in G\).
Then she has to factor \(s = xy\) into \(x\) and \(y\) which can be verified 
using the recorded values \(g^x\) and \(g^y\).
Second, she can find the discrete logarithms of the recorded \(g^x\) and 
\(g^y\) to verify whether \(k = g^{xy}\) it true or not.

However, it can be argued that this is the case already with the current 
protocol.
The only difference is that Alice and Bob cannot give Eve any key to 
\enquote{prove their innocence}, they can just deny because they do not 
remember the keys due to \ac{PFS}.


\subsubsection*{Acknowledgements}

This work was funded by the Swedish Foundation for Strategic Research grant SSF 
FFL09-0086 and the Swedish Research Council grant VR 2009-3793.


%\begin{filecontents}{otrmsg.submission.bbl}
%\end{filecontents}
\printbibliography{}
